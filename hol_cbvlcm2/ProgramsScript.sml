open HolKernel Parse boolLib bossLib;
open arithmeticTheory;
open listTheory;
open PrelimsTheory;
open LTheory;
open RefinementsTheory;

val _ = new_theory "Programs";

Datatype:
  Pro = retT | varT num Pro | appT Pro | lamT Pro Pro
End

(* Inductive Pro := retT | varT (n:nat) (P:Pro) | appT (P:Pro) | lamT (Q P:Pro). *)

(* compilation function γ : Ter → Pro → Pro
    translates terms into programs: *)
Definition gamma:
  gamma s P =
    case s of
      | var n => varT n P
      | app s t => gamma s (gamma t (appT P))
      | lam s => lamT (gamma s retT) P
End
(*
Fixpoint γ (s: L.term) P: Pro :=
  match s with
    var n => varT n P
  | app s t => γ s (γ t (appT P))
  | lam s => lamT (γ s retT) P
  end.*)

(* Implicit Types A B : list term. *)

(* decompilation function δ P A of type Pro → L(Ter) → O(L(Ter))
    translates programs into terms *)
Definition delta:
  delta P A =
    case P of
    | retT => SOME A
    | varT n P => delta P (var n ::A)
    | lamT Q P =>
      (case (delta Q []) of
        | SOME [s] => delta P (lam s::A)
        | _ => NONE)
    | appT P =>
      (case A of
        | t::s::A => delta P (app s t::A)
        | _ => NONE)
End

(*
Function δ P A: option (list term) :=
  match P with
    retT => Some A
  | varT n P => δ P (var n::A)
  | lamT Q P => match δ Q [] with
               | Some [s] => δ P (lam s::A)
               | _ => None
               end
  | appT P => match A with
               t::s::A => δ P (app s t::A)
             | _ => None
             end
  end.
  *)

(* Fact 10 *)
Theorem decompile_correct:
  ∀P A s. delta (gamma s P) A = delta P (s::A)
Proof
  Induct_on `s`
  >- (rw[Once gamma] >> rw[Once delta])
  >- (rw[Once gamma] >> rw[Once delta])
  >> rw[Once gamma] >> rw[Once delta] >> rw[Once delta]
QED

Definition repsP:
  repsP P s ⇔ delta P [] = SOME [s]
End

(* Definition repsP P s := δ P [] = Some [s].
Notation "P ≫P s" := (repsP P s ) (at level 70).
Notation "(>>P)" := repsP (at level 0).*)

(* Fact 11 *)
Theorem decompile_append:
  ∀P A A' B.
    delta P A = SOME A' ⇒ delta P (A ++ B) = SOME (A' ++ B)
Proof
  Induct_on `P` >> rw[]
  >- fs[Once delta]
  >- ()

  ho_match_mp_tac delta_ind >> rw[] >>

QED
(*
Lemma decompile_append P A A' B:
  δ P A = Some A' -> δ P (A++B) = Some (A'++B).
Proof.
  revert B A'. functional induction (δ P A);intros B A'. all:try congruence;intros eq;cbn in *.
  -congruence.
  -erewrite IHo. all:eauto.
  -rewrite e0. erewrite IHo0. all:eauto.
  -erewrite IHo. all:eauto.
Qed.*)

(*Some lemmas to simplify reasoning*)

Theorem decompile_lamT_inv:
  delta (lamT Q P) A = Some B -> ∃s. delta Q [] = Some [s] ∧ delta P (lam s::A) = Some B.
Proof
QED
(*
Lemma decompile_lamT_inv P Q A B:
  δ (lamT Q P) A = Some B -> exists s, δ Q [] = Some [s] /\ δ P (lam s::A) = Some B.
Proof.
  functional inversion 1. subst. cbn. rewrite H3. eauto.
Qed.*)

Definition substP:
  substP P k R =
    match P with
      retT => retT
    | varT n P => if Dec (n=k) then lamT R (substP P k R) else varT n (substP P k R)
    | lamT Q P => lamT (substP Q (S k) R ) (substP P k R)
    | appT P => appT (substP P k R)
End

(*
Fixpoint substP P (k:nat) R: Pro :=
  match P with
    retT => retT
  | varT n P => if Dec (n=k) then lamT R (substP P k R) else varT n (substP P k R)
  | lamT Q P => lamT (substP Q (S k) R ) (substP P k R)
  | appT P => appT (substP P k R)
  end.
*)


Theorem substP_rep_subst':
  repsP R t
  ⇒ delta Q A = SOME B
  ⇒ delta (substP Q k R) (MAP (subst s k (lam t)) A)
    = Some (MAP (subst s k (lam t)) B).
Proof
QED

(*
Lemma substP_rep_subst' Q R t k A B:
  R ≫P t
  -> δ Q A = Some B
  -> δ (substP Q k R) (map (fun s => subst s k (lam t)) A)
    = Some (map (fun s => subst s k (lam t)) B).
Proof.
  revert k B. functional induction (δ Q A);intros k B repR repQ. all:try congruence.
  all:cbn in *.
  -congruence.
  -erewrite <- IHo. 2,3:now eassumption.
   cbn. decide _. all:cbn.
   +rewrite repR. reflexivity.
   +reflexivity.
  -erewrite IHo. 2-3:eassumption. cbn. apply IHo0. all:eassumption.
  -apply IHo. all:eassumption.
Qed.*)

Inductive boundP:
  boundP retT k ∧
  (n < k ⇒ repsP P k ⇒ repsP (varT n P) k) ∧
  (repsP Q (SUC k) ⇒ repsP P k ⇒ repsP (lamT Q P) k) ∧
  (repsP P k ⇒ repsP (appT P) k)
End
(*
Reserved Notation "P <P k" (at level 70).

Inductive boundP : Pro -> nat -> Prop :=
  boundP_ret k : retT <P k
| boundP_var k n P : n < k -> P <P k -> varT n P <P k
| boundP_lam k P Q : Q <P S k -> P <P k -> lamT Q P <P k
| boundP_app k P : P <P k -> appT P <P k
where "P <P k" := (boundP P k).
Notation "'(<P' k ')'" := (fun P => P <P k) (at level 0, format "'(<P' k ')'").

Hint Constructors boundP.
*)

Definition closedP:
  closedP P = repsP P 0
End

(*
Definition closedP P:= P <P 0.
Hint Unfold closedP.*)

Theorem bound_compile:
  boundL s k ⇒ boundP P k ⇒ boundP (gamma s P) k
Proof
QED

(*
Lemma bound_compile k s P: s <L k -> P <P k -> γ s P <P k.
Proof.
  induction 1 in P|-*;intros bnd;cbn. all:eauto.
Qed.
Generated by coqdoc and improved with CoqdocJS
*)

val _ = export_theory ()