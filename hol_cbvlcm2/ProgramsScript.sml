open HolKernel Parse boolLib bossLib;
open arithmeticTheory;
open listTheory;
open PrelimsTheory;
open LTheory;
open RefinementsTheory;

val _ = new_theory "Programs";

Datatype:
  Pro = retT | varT num Pro | appT Pro | lamT Pro Pro
End

(* Inductive Pro := retT | varT (n:nat) (P:Pro) | appT (P:Pro) | lamT (Q P:Pro). *)

(* compilation function γ : Ter → Pro → Pro
    translates terms into programs: *)
Definition gamma:
  gamma s P =
    case s of
      | var n => varT n P
      | app s t => gamma s (gamma t (appT P))
      | lam s => lamT (gamma s retT) P
End

(* Implicit Types A B : list term. *)

(* decompilation function δ P A of type Pro → L(Ter) → O(L(Ter))
    translates programs into terms *)
Definition delta:
  delta P A =
    case P of
    | retT => SOME A
    | varT n P => delta P (var n ::A)
    | lamT Q P =>
      (case (delta Q []) of
        | SOME [s] => delta P (lam s::A)
        | _ => NONE)
    | appT P =>
      (case A of
        | t::s::A => delta P (app s t::A)
        | _ => NONE)
End

(* Fact 10 *)
Theorem decompile_correct:
  ∀P A s. delta (gamma s P) A = delta P (s::A)
Proof
  Induct_on `s`
  >- (rw[Once gamma] >> rw[Once delta])
  >- (rw[Once gamma] >> rw[Once delta])
  >> rw[Once gamma] >> rw[Once delta] >> rw[Once delta]
QED

Definition repsP:
  repsP P s ⇔ delta P [] = SOME [s]
End

(* Definition repsP P s := δ P [] = Some [s].
Notation "P ≫P s" := (repsP P s ) (at level 70).
Notation "(>>P)" := repsP (at level 0).*)

(* Fact 11 *)
Theorem decompile_append:
  ∀P A A' B.
    delta P A = SOME A' ⇒ delta P (A ++ B) = SOME (A' ++ B)
Proof
  Induct_on `P` >> rw[]
  >- fs[Once delta]
  >- (gs[Once delta] >> first_x_assum drule >> rw[] >>
      simp[Once delta])
  >- (gs[Once delta] >> Cases_on `A` >> fs[] >>
      Cases_on `t` >> fs[] >> first_x_assum drule >> rw[] >>
      simp[Once delta])
  >> gs[Once delta] >>
  Cases_on `delta P []` >> fs[] >>
  Cases_on `x` >> fs[] >>
  simp[Once delta] >> Cases_on `t` >> gs[] >> rw[] >>
  first_x_assum drule >> rw[]
QED

(*Some lemmas to simplify reasoning*)

Theorem decompile_lamT_inv:
  ∀Q P A B.
    delta (lamT Q P) A = SOME B ⇒
    (∃s. delta Q [] = SOME [s] ∧ delta P (lam s::A) = SOME B)
Proof
  rw[Once delta] >> Cases_on `delta Q []` >> fs[] >>
  Cases_on `x` >> fs[] >> Cases_on `t` >> fs[]
QED

Definition substP:
  substP P k R =
    case P of
      retT => retT
    | varT n P =>
      if (n = k) then lamT R (substP P k R) else varT n (substP P k R)
    | lamT Q P => lamT (substP Q (SUC k) R) (substP P k R)
    | appT P => appT (substP P k R)
End

Theorem substP_rep_subst':
  ∀R t Q A B k R.
    repsP R t ⇒
    delta Q A = SOME B ⇒
    (delta (substP Q k R) (MAP (λs. subst s k (lam t)) A)
      = SOME (MAP (λs. subst s k (lam t)) B))
Proof

QED

(*
Lemma substP_rep_subst' Q R t k A B:
  R ≫P t
  -> δ Q A = Some B
  -> δ (substP Q k R) (map (fun s => subst s k (lam t)) A)
    = Some (map (fun s => subst s k (lam t)) B).
Proof.
  revert k B. functional induction (δ Q A);intros k B repR repQ. all:try congruence.
  all:cbn in *.
  -congruence.
  -erewrite <- IHo. 2,3:now eassumption.
   cbn. decide _. all:cbn.
   +rewrite repR. reflexivity.
   +reflexivity.
  -erewrite IHo. 2-3:eassumption. cbn. apply IHo0. all:eassumption.
  -apply IHo. all:eassumption.
Qed.*)

Inductive boundP:
  boundP retT k ∧
  (n < k ⇒ repsP P k ⇒ repsP (varT n P) k) ∧
  (repsP Q (SUC k) ⇒ repsP P k ⇒ repsP (lamT Q P) k) ∧
  (repsP P k ⇒ repsP (appT P) k)
End
(*
Reserved Notation "P <P k" (at level 70).

Inductive boundP : Pro -> nat -> Prop :=
  boundP_ret k : retT <P k
| boundP_var k n P : n < k -> P <P k -> varT n P <P k
| boundP_lam k P Q : Q <P S k -> P <P k -> lamT Q P <P k
| boundP_app k P : P <P k -> appT P <P k
where "P <P k" := (boundP P k).
Notation "'(<P' k ')'" := (fun P => P <P k) (at level 0, format "'(<P' k ')'").

Hint Constructors boundP.
*)

Definition closedP:
  closedP P = repsP P 0
End

(*
Definition closedP P:= P <P 0.
Hint Unfold closedP.*)

Theorem bound_compile:
  boundL s k ⇒ boundP P k ⇒ boundP (gamma s P) k
Proof
QED

(*
Lemma bound_compile k s P: s <L k -> P <P k -> γ s P <P k.
Proof.
  induction 1 in P|-*;intros bnd;cbn. all:eauto.
Qed.
Generated by coqdoc and improved with CoqdocJS
*)

val _ = export_theory ()